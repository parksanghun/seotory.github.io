---
layout: post
title: oracle 7r
date: 2016-07-02  9:00:01 +0900
description: 
image: 
categories: study
published: false
comments: false
tags:
---

# oracle 7r

스터디 7주차

# 대용량 데이터베이스 1

join은 index의 구조를 모르고는 사용할 수 없다.

## index

### b-tree 인덱스 (바이너리 트리)

개념적으로는 발란스드 트리라고 하는게 더 적절하다.

- 인덱스가 최초 접근하는 하나의 블럭을 `root block`이라고 한다.
  - `root block`에는 절반의 각각의 값이 어디에 있는지 저장한다.
- 마지막 노드는 `leaf block`이라고 한다.
  - `leaf block`에만 값의 주소값을 가지고 있다.
- `root block`과 `leaf block` 사이의 블럭을 `branch block` 이라고 한다.
- 인덱스는 값들의 블럭 id를 가지고 있다.
- 인덱스는 기본적으로 소팅되어 있기 때문에 `leaf block`은 전후의 값을 링크로 가지고 있다.
  - index scan 할 때 성능상 매우 유리하다.

### 인덱스 경유 테이블 엑세스

- 인덱스 액세스를 해서 만족하는 row id를 가지면 이 id를 가지고 테이블을 재조회
- 인덱스의 결과값은 인덱스의 소팅된 속도로 결과 값이 나와야 한다.
  - 소팅된 결고를 뽑고 싶다면 인덱스르 이용한다.
- 인덱스의 정보를 가지고 테이블을 액세스 할때 한건의 row 를 가져 오는것이 아니라 블럭 단위를 메모리로 가져오는데 이것을 랜덤 block io라고 한다. 만약 랜덤 블럭 io가 증가하면 속도가 느려지며 퍼포먼스가 떨어지게 된다. 이것은 성능의 중요한 지표이다.

### 인덱스의 구조

1. 인덱스는 PGA영역을 뒤짐
2. 없으면 물리상 디스크에서 뒤짐
3. 찾으면 물리상 디스크에 찾은 데이터를 다시 PGA로 블럭을 올림
4. 반환
5. 위의 단계를 반복

- 인덱스는 반드시 한 건을 더 찾아서 확인한다
  - 유니크 인덱스인 경우는 한 건을 더 찾지 않는다.

512 바이트 시스템 블럭단위, 현재 인팍은 4k 오라클 블럭이 잡힘

### 인덱스 생성

- 인덱스는 소팅이 중요하기 때문에 소팅을 위한 insert cost가 크다
- 인덱스 블럭은 헤더와 바디(실제 인덱스 로우)가 있다
- 인덱스 바디는 값과 row id를 가지고 있다.
- 블럭이 다 차면 상위 블럭을 만들고 값으로 하위의 처음의 하위 블럭 id를 헤더에 적는다.

### 인덱스를 사용안하는 경우

- 인덱스 컬럼에 함수를 씌우는 경우
- 부정형이 왔을 경우 사용할 수 없음 `<>`
  - `not exists`를 사용하면 `<>`과 의믹가 같지만 인덱스 사용 가능함
- null, not null 인 경우 사용 못함
  - 비트맵 인덱스에서는 null값을 저장하기 때문에 사용함
- `=` 과 `like` 중에서 보통 옵티마이져 선택은 효율이 좋은 `=`를 선택함, 그러나 데이터 분포도를 보고 `like`를 사용하는 경우도 있음
- rtrim 함수를 이용해서 의도적으로 인덱스를 사용하지 않는 경우도 있다. 인덱스의 스캔 범위를 보고 결정

### nested loop

```sql
SELECT X.ORDNO, ORDDATE, ITEM
FROM ORDER1T X, ORDER2T Y
WHERE RTRIM(X.ORDNO) = Y.ORDNO
	AND X.ORDDATE LIKE '9411%'
	AND Y.ORDDEPT = '710'
```

위의 쿼리 같은 경우 T1의 인덱스를 거쳐서 나온 데이터를 가지고 T2를 건바이건으로 조회한다.

> ### 클러스터링 팩터
> 데이터의 밀집도를 이야기한다. 이 밀집도가 높을 수록 랜덤 블럭 io가 덜 발생하며 cost가 낮아진다.

### index merge

- 인덱스 머지는 옵티마이져가 결정
- 상식적으로는 첫번째 인덱스 후에 나온 값을 상수 조건으로 거르면 되지만 이런 방법을 쓰지 않고 인덱스 머지를 쓰는 이유는 랜덤 블락 io를 줄이기 위함이다.
  - 둘이 결합하니 성능이 좋을때만 인덱스 머지가 좋다.
  - 바꿔 말하면 이런 형태의 인덱스 머지가 뜬다면 결합 인덱스를 만드는 것이 바람직하다.
- 실제로 볼 경우는 거의 없다.

한 테이블에서 두개의 인덱스 조건이 발생하면 옵티마이져가 merge 로 데이터를 찾을 수도 있다.

```sql
SELECT COL1, COL2, ......
FROM TAB1
WHERE A = 'ABC'
	AND B LIKE '12%'
```

위와 같은 쿼리는 인덱스 머지가 범위로 처리되기 때문에 매우 불리해진다.

### 결합 인덱스

- 결합 인덱스를 만들기 전에 선분으로 들어오는 데이터를 점으로 바꾸는 작업이 필요하다.
  - 대부분 form에 서브쿼리가 들어가게 된다.
- 결합 인덱스를 사용할 때에는 처음 액세스 되는 컬럼에 `like` 조건(범위 조건)이 없어야 한다.
