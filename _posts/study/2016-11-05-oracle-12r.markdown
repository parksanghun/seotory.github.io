---
layout: post
title: oracle 12r
date: 2016-11-05  9:06:29 +0900
description:
image:
categories: study
published: false
comments: false
tags:
---
오라클 12주차

# 조인과 서브쿼리

where절에 있는 서브쿼리에 대하여....

> 서브쿼리는 메인쿼리의 집합에 변화를 줄 수 없다.

- 서브쿼리는 매인쿼리의 결과 셋을 변경시킬 수 없다.
- 서브쿼리가 먼저 돌아서 상수화 된다 -> 제공자 역활
  - 메인쿼리에서 서브쿼리에서 나오는 상수 값을 대하여 인덱스가 되어 있어야한다. 이 말인즉 서브쿼리에서 메인쿼리에 대한 where절 조건이 없어야 한다.
  - 메인쿼리의 컬럼을 서브쿼리의 where절에서 사용되면 제공자 역활을 하지 못하고 확인자 역활을 한다.
  - 제공자 역확을 하는 서브쿼리는 반드시 sort를 선행함으로 유니크하게 만든다.
- m:1인 경우 서브쿼리로 도는것이 아니라 조인으로 풀려서 작동할 가능성이 크다. 플랜을 확인하자. 반대로 1:m으로 작동하면 서브쿼리가 먼저 정리된다.
- 서브쿼리 사용시 m:m 은 m:1의 관계로 풀린다.
- where절의 서브쿼리는 플랜과 다르게 작동할 수 있다. 왜냐먼 무엇을 먼저해야할지에 대한 힌트를 줄 수 없기 때문이다.
- key1(where %), key2(where in)으로 조건이 걸리면 내부적으로 (key1% and key2) or (key1% and key2) 이런식으로 or 조건이 풀리게되므로 엄청난 비효율이 발생한다.
- key1이 범위로 들어오는 쿼리라면 join을 사용하는 방법으로 고려해야한다.
- exists로 서브쿼리가 들어가면 제공자 역활을 하는것이 아니라 확인자 역확을 하게되므로 서브쿼리의 where절에는 보통 메인쿼리의 조건이 들어가있을 가능성이 높다.
- 서브쿼리가 플랜상에서 filter처리가 되는 경우가 있다. 이것은 exists의 개념으로 쿼리를 실행하는 의미이다.
  - 내부적으로 buffer를 활용하기 때문에 데이터 소트가 중요하다.
- 명시적으로 메인쿼리와 서브쿼리의 핸들링을 할 수 있는 방법은 없다.
- 메인쿼리에 상수값을 제공하는 역활정도로 사용된다면 서브쿼리가 join보다 유리하다.
- where절에 다중 in 조건을 사용하면 옵티마이저가 쿼리를 이상하게 풀 가능성이 있다.
- where절에 between과 like가 연속으로 오는 인덱스 조건일 경우 in의 서브쿼리의 성능이 좋을 수 있다. 그러나 이런 경우 m:1의 경우가 되기 때문에 join으로 풀릴 가능성이 많다. 강제적으로 서브쿼리를 먼저 돌게 하려면 상수로 연결되는 연결고리를 깨뜨려서 강제로 서브쿼리를 먼저 돌게 만들 수 있다.
- m:m인 경우 sort merge로 연결될 가능성이 크다.
- like 조건 뒤에 not in 조건이 오는 경우 부정형에는 인덱스를 사용할 수 없음으로 제공자 역확을 못하고 확인자 역활밖에 할 수가 없다. 이런 경우 sort merge anti 또는 hash anti 조인으로 유도된다.
  - sort merge anti 조인에서는 반드시 is not null 조건을 주어야한다. 그리고 나서 /\*+ merge aj \*/이라는 힌트를 사용해야한다.
  - 때에 따라서  /\*+ hash aj \*/ 성능이 좋을 수도 있다.
- 확인자 역활에서는 메인쿼리에서 전달되는 상수값을 서브쿼리에서 인덱스로 받을 수 있느냐가 주요하다.
- all -> 무조건 확인자 역활
- any(이 중에 하나라도 만족하면 = exists) -> 무조건 확인자 역활이지만 all 보다 훨씬 유리
- 제공자 역활로 사용되는 서브쿼리가 in 조건으로 다중이라면 1개를 제외하고 모두 빼내야 한다.
