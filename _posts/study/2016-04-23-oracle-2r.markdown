---
layout: post
title: oracle 2r
date: 2016-04-23  8:57:13 +0900
description: 
image: 
categories: study
published: false
comments: false
tags:
---

오라클 2 주차 스터디 내용입니다.

# oracle architectural components

## oracle server (DBMS)

> 로지컬 아키텍쳐 > 테이블, 인덱스  
> 피지컬 아키텍쳐 > DB의 구조

### oracle instance

메모리영역과 백그라운드 프로세스 구조들을 묶어서 부르는 말이다. 

- shared pool
  
  SGA는 쉐어드 메모리를 말하며 이는 멀티프로세스가 작동되도록 한다. SGA안에 Shared Pool은 libarary chache, data dictionary cache로 나뉜다.
  
  이 영역(Shared Pool)은 우리가 임의로 지정할 수 없다. 이곳은 io가 많이 발생하는 곳이며 힛레이트가 최소 `95%` 이상이 되어야 퍼포먼스에 이상이 없다.
  
  - libarary cache  
    쿼리를 보내면 여기에 적재되어 캐싱함, 수도파일이 여기서 생성됨

  - data dictionary  
    오라클 내부에서 사용되는 테이블이 어떤 구성, 권한 등의 데이터를 이곳에 적재함
  
  **여기서 주의할 것은 상수가 다른 값으로 전달되었을 때, 라이브러리 캐쉬는 이것들을 모두 다른 캐쉬로 인식하여 사용하지 않는 쿼리들을 없애고 들어오는 쿼리를 캐쉬한다. 즉 바인딩되지 않은 쿼리가 전달되면 DB에 부하가 간다. 즉 바인딩이 안된 쿼리는 런타임 파싱을 시도한다.**
  
  다이나믹 sql은 기본적으로 메소드 1, 2, 3, 4가 있다. 변수바인딩은 메소드 1, 메소드 4는 테이블이 어떤 테이블이 정의될지 모르는 경우가 메소드 4이다. dba는 다이나믹 sql중에 메소드 4를 쓰지 말라고 해야한다.

  - database buffer cache
    
    모든 데이터는 엑세스 하기 전에 여기로 이동시켜야 한다. 결과 값을 뽑기 위한 모든 데이터를 말한다. 쿼리가 늦다고하는 것은 결과집합을 뽑기위해 데이터를 읽는 시간을 말한다. 보통 힛레이트 80%, 관리를 잘하면 90%을 추천한다.
    
    쿼리를 잘못짜서 데이터를 많이 읽어드리면 예전에 적제되어있는 데이터를 내린다. 이 말은 추가적인 io 작업이 발생하는 것을 뜻한다.
    
    즉 이 부분이 full나지 않기 위해서는 얼마나 불필요한 데이터를 엑세스하지 않는가 -> 다른말로 sql을 잘 짜야한다.
    
    **데이터베이스의 가장 큰 성능 이슈는 `io`이다.**
    
    > db에서 io단위는 블럭(black)단위 이다.

  - log buffer cache
    
    데이터베이스에서 일어나는 모든 변경사항을 저장하는 곳이다. 때문에 다른 데이터베이스보다 퍼포먼스가 살짝 떨어져보인다. 이 메모리에 적제된 녀석이 파일로 다시 적재된다.(redo log files)
    
    - 3초에 한번 파일로
    - 1/2 이상이 차면 또 파일로


  - large pool

  - java pool
    
- background process

  - RECO
  - PMON  
    server process를 강제로 죽이면 뒷처리를 하기 위해 이 프로세스가 바뻐진다.

  - SMON  
    시스템 모니터링 db를 모니터한다. 인스턴스 페일 > 정전의 경우. 스타트업 할때 SMON이 이를 감지하고(싱크가 안맞음) redo log files의 정보를 기반으로 복구를 시도한다.

  - DBWR  
    실질적으로 변경된 사항을 db에 기록하는 프로세스, 이 프로세스는 무조건 write만 한다. 싱크 io에서는 디스크 갯수만큼 프로세스를 띄운다. 어싱크(비동기) os에서는 프로세스는 1개만 띄운다.

  - LGWR  
    log 기록하는 녀석

  - CKPT  
    체크 포인트 프로세스

    7버젼까지는 이게 없었음 원래는 LGWR이 이 역활까지 하고 있었음 그러나 이게 너무 바빠서... 분리

    체크 포인트 이벤트는 시스템 체인지 넘버가 바뀌게되면 내부적인 메카니즘에 따라 발생하게 된다. 이후에 data files, control files, redo log files의 헤더의 넘버를 맞춘다. 이 순간 DB는 멈추고 데이터 싱크를 맞춘다. 데이터 무결성을 지키기 위함이다.

    체크 포인트 이벤트 발생 조건 
    - 로그 파일이 다 쓰여지고 다음 로그 파일로 넘어갈 때(로그 스위치가 일어나는 시점)
    - DBA가 강제로 실행

    체크 포인트 낫 컴플릿트 -> 이건 db가 멈춘 것이다. 권고 하는 로그 스위치는 하루에 2~30번을 이야기한다.
  - ARC0
  - DBW0
  - D000


### oracle database

물리적으로 저장되는 공간들을 칭하는 말.

- data files
- control files
- redo log files
- control files  
  오라클을 스타트업하면, 이 파일을 읽어서 data files에서 헤더의 시스템 넘버를 체크하며 이상한 부분이 발견하면 복구를 시도한다.
- parameter file  
  옵션 정의 파일, 없어도 괜찮음
- password file  
  필요 없어도 됨.

## server process

server process는 커넥션에 1:1 대응하여 생성된다. 

## PGA(program global area)


## logical structure oracle database

앞서서 unix의 파일시스템 create 란 저장장치의 용량을 읽어서 블락단위로 넘버를 붙이는 것을 이야기한다.(윈도우에서는 포맷) DB역시 포맷을 시도한다. os의 파일시스템에서는 정보가 부족하여 그대로 사용할 수가 없다. 이것은 `create tablespace`을 뜻한다.

```sql
create tablespace tsql
datafile '.../.../.../tsql.dbf' size 1G; 
```

위의 명령어는 크기 1G의 데이터를 만들면서 오라클의 블럭단위로 만드는 것을 이야기한다. 즉 오라클의 포맷이다. 

os에서 포맷이 안된(파일 시스템이 설치 안된) 디스크를 `rowdevice`라고 한다. 여기에 오라클 스페이스를 만들려면 os의 볼륨 메니져 툴을 이용해서 사용하면 된다.

```sql
-- vol 1 / 01  > 10g
create tablespace tsql
datafile '/val1/01' size 1G; 
```

볼륨 사이즈가 10g인데 1g만 사용하면 9g는 버려진다. 이것은 os 의 파일시스템을 거치지 않기 때문에 io의 효율이 좋아진다. 대신 파일시스템이 없기 때문에 파일 이동, 삭제 등이 안된다. 운영중에는 효율이 좋으나, backup을 위한 공간으로는 좋지 않다.

디비의 오프젝트는 두개로 나뉜다.

- 물리적인 공간이 필요한 녀석 > 테이블 등
- 물리적인 공간이 필요없는 녀석 > 뷰, 펑션 등

연속된 블럭이 익스텐트, 연속된 익스센트는 세그먼트 라고 칭한다. 세그먼트 저장구조의 관점에서 이야기하는 것이다. 

오브젝트는 반듯히 하나의 스페이스에 들어있어야 한다. 하지만 파티션(테이블)은 스페이스에 세그먼트가 따로 존재할 수 가 있다. 

```sql
create user a
default tablespace ....
```

# data blocks

기본적으로 블럭에는 해더가 존재하고 데이터를 차곡차곡 쌓는다. 어느시점이 되면 더이상 데이터를 넣지 않는데 이유는 `PCTFREE`로 20% 정도가 잡혀있기 때문다. 

A 블럭에 80%정도가 차서 B 블럭으로 분할을 했는데 A 블럭에 row data가 delete가 되서 공간이 떨어지더라고 약 40% 이하가 되기 전까지는 A 블럭에 새로운 데이터를 쓰지 않는다. 이렇게 하면 파편화 및 문제가 많기 때문에 익스텐트가 나옴.

익스텐트 관리기법 2개

- dictinary manage(여전 디폴트)  
  data 파일에서 관리
- locally manage
  이제는 이걸로 관리한다.

row migation(로그 마이그레이션) 이란 row 데이터가 update 되었는데 블럭이 다차서 블럭을 새로 만들고 데이터를 거기에 담는다. 이렇게 되면 전에 있던 블럭에 로우어드레스가 틀어지는데, 전에 있던 블럭이 분할된 블럭의 로우어드레스를 담고 있다. 

row chain(로우 체인)은 하나의 데이터가 너무 커서 블럭이 걸쳐서 저장되는 경우이다. 이런 경우는 거의 없다.

# oracle instance startup 과정

어떤 user에게 스타트업의 권한을 줄 것인가? 

디비의 스타트업 단계

1. SHUTDOWN
2. NOMOUNT  
  인스턴스만 스타트업이 된 상태 즉 백그라운드 프로세스가 뜬 상태. 이 단계가 필요한 이유는 처음 db를 설치하면 아무것도 없기 때문
3. MOUNT  
  마운트 단계에서는 컨트롤 파일을 오픈한다. 이 단계에서 db의 구조를 파악한다. 컨트롤 파일에서 읽었던 기준으로 오픈을 한다. 뭔가 이상하면 오픈을 못하고 복구 단계로 들어간다.
4. OPEN
 
셧다운에는 옵션이 존재한다. `[ NORMAL | TRANSACTIONAL | IMMEDIATE | ABORT ]`

- 노멀 < 트랜젝션 및 작업이 끝날때까지
- 트랜젝션 < 트랜젝션은 기달려줌 
- 이미데이트 < 지금 당장 셧다운 지금 하는 작업은 롤백함

위의 3개는 정상적으로 db가 정상 종료된 상황

- 어보트 < 그냥 종료 즉 비정상 종료이다.

# Dedicated Server vs. Shared Server (MTS: Multithreaded Server)

멀티스레드 방식은 유져프로세스와 서버프로세스를 1:1로 사용하는 것이 아니라 쉐어드 서버 프로세스를 먼저 띄워서 사용한다. 이것은 어디로 결과를 줘야할지 모르기 때문에 dispatcher 백그라운드 프로세스를 추가적으로 띄운다. 

그러므로 유져 프로세스는 디스페쳐 프로세스와 통신을 하고 있고, 디스페쳐는 리퀘스트 큐로 요청을 보낸다. 서버 프로세스들은 대기하고 있다가 리퀘스트 큐에 데이터를 처리한다. 그리고나서 결과값은 디스페쳐만큼 리스판스 큐 를 만들고 리스판스 큐에 데이터가 담기면 디스페쳐가 이것을 가져다가 유져 프로세스에게 전달한다.

MTS로 서버를 스타트업 하면 디스패쳐서버랑, 쉐어드서버 두 개가 같이 실행되는데 그럼 어느 것을 MTS로 붙이느냐의 문제는 어플리케이션에서 설정한다.