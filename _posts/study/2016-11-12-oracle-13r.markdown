---
layout: post
title: oracle 13r
date: 2016-11-12 9:04:41 +0900
description:
image:
categories: study
history: 
  use: true
  data: 
    - 20161112
    - 20161130
published: false
comments: false
tags:
---

# 인라인 뷰의 활용

- join을 하기전에 줄일 수 있는 데이터는 미리 줄여놓고 join을 건다.
- decode의 실행횟수를 줄이기 위해 인라인 뷰를 활용한다.
- `rownum`이 있으면 무조건 단독 실행해야 한다.
- view가 생성되면 index를 사용할 수 있는 상태가 아니다.
- 내부에서 join으로 집합을 한번 줄일 수 있다면 인라인 뷰를 사용하는 것이 유리할 때도 있다.
- where ~ (+) in ~ 을 사용하면 문법 에러가 발생한다.
  - 이런 경우 아우터 조인의 대상에 대해서 뷰로 만들고 실행한다.
  - 또는 인라인 뷰로 하나를 만들어서 해결한다.
  - 또는 조건을 바꾼다. where ~ (+) in ~ or ~
- 두 번의 아우터조인이 필요한 경우 한쪽을 먼저 join걸어서 합친 후에 다시 아우터를 사용한다. 집합을 두개에 대상에 대해서 아우터 조인을 할 수 없기 때문이다.
- 최신 오라클에서는 인라인뷰에서도 order by 가능하다.
- select 절에 func을 줄일려면 group by를 사용해서 row 수를 줄인다.
- 서로 다른 컬럼을 하나로 합쳐서 `+`를 이용해서 새로운 컬럼으로 만들 수 있고, 다른 집합은 `union all`을 사용해서 하나의 집합으로 만들 수 있다.
- `union`을 사용한다고 하면 데이터 중복 액세스에 주의한다.
- `in`, `in`을 다중으로 주면 경우의 수의 분기를 옵티마이져가 못한다. full table scan을 사용할 가능성이 크다.
  - 이런 경우 조건 1,2를 합쳐서 하나의 컬럼으로 만들어서 `in` 조건을 하나로 만든다.
- `like`, `between` 등의 선분 조건이 들어오면 `index`의 비효율이 발생할 수 밖에 없다.
- `or`가 들어오면 옵티마이져는 쿼리를 분리시켜서 실행 후에 하나로 합친다 즉 성능에 매우 않좋다.
  - ~ or ~ and ~ => (+) = decode 로 풀어서 해석 가능하다.
- 같은 쿼리에서는 하나의 인덱스 선택된다. (캐싱 이유) 즉 like가 여러개의 조건절인 경우 효율이 좋은 것이 아니다.
  - 이런 경우 where 상단에서 조건 체크를 해서 `union all`을 해주는 것이 좋다.
- where 절에서는 보통 역순으로 찾는데 이것은 순수하게 체크 조건으로 역활을 할때에 역순 검사를 시도한다. 그러나 처리 주관조건(핵심조건)이 동일하게 2가지가 있으면 먼저 적은 컬럼을 이용해서 처리한다.

# 논리합 연산자의 액세스 효율화

- like, `or` 연산자가 들어왔는데 주관 체크 조건이 없으면 full scan을 한다.
- 복잡한 `or` 연산자인 경우 full scan이 된다.
- 인덱스 스캔 or 풀 스캔 = 풀 스캔
- 가능한 `or`를 사용하지 않는 것이 답이다.
- 컬럼 수가 적고 로우가 많으면 블럭 안에 많은 로우가 들어갈 수 있음으로 컬럼을 늘리는것 보다 로우를 늘리는 것이 db 관점 액세스에서 훨씬 유리하다.
- `like` 조건의 선분이력이라면 `in`을 사용해서 점이력으로 바꾸는 방법을 생각해본다.
- `in` 안에서 서브쿼리를 사용하면 플랜 상으로는 분리되지 않지만 내부적으로는 분리를 해둔 상태이다.
- 모조 테이블을 만들어서 참조 하는 방법이 있다. `ymd_dual`, `ym_dual`, `capy_t` 대표적으로 이런 테이블이 있다.
- `in` 조건에 상수 조건이 들어오면 무조건 uniqe로 만든 후에 실행한다. 상수 조건을 입력하면 모두 실행한다.
- 처리 범위, 처리 양에 따라서 쿼리의 절대적인 것은 없다. 그래서 데이터의 분포도를 보는 것이 중요하다.
- 인덱스의 결합된 컬럼수에 따라 결합처리 실행계획 수립이 달라진다.
- 컬럼이 3개 이하인 경우는 대부분 정상적인 결합처리 실행계획 수립
- 컬럼이 4개 이상인 경우는 상황에 따라 달라짐
  - 예를 들어서 인덱스는 컬럼이 4개로 구성되었으나 where절에 컬럼이 3개인 경우 인덱스를 사용할 수 없음으로 hint `/*+ use_concat*/`를 사용하여 인덱스를 사용하게끔 한다.
- 인덱스의 컬럼이 1개인 경우, `in` 뒤에  `between`같은 경우 정상적으로 동작하나, `in` 뒤에 `in`이 오면 모든 컬럼을 스캔할 수 있다. 왜냐하면 범위 뒤에 범위는 시작과 끝을 알 수 있으나 범위 뒤에 점은 시작과 끝을 알 수 없기 때문이다.
- 결합인덱스가 4개 이상이면 두번째까지는 in을 사용할 수 있고 그 뒤로는 like나 between을 사용해야한다.
- 제공자 역활을 못하는 서브쿼리는 아래와 같이 해결한다
  - 확실한 선조건을 부여한다
  - 서브쿼리 select - list 컬럼을 가공한다. (연결고릴를 해제한다. 예를 들어서 ``컬럼||''``)
  - 아예 서브쿼리를 `group by`를 한다.
  - `push_subq` hint를 이용한다. 다만 이 힌트는 잘 작동을 안한다.

# 중복된 in 조건 활용

1. 규칙1 : 3개 컬럼이하의 인덱스는 상수(변수포함) IN 조건은 정상적인 분리
2. 규칙2 : 4개 컬럼이상의 인덱스의 중복 상수IN 조건은 2컬럼까지 분리
3. 규칙3 : 4개 컬럼이상 인덱스의 상수(변수포함) IN 조건은 연속선에 해당하는조건이 뒤에 오면 정상적인 분리
4. 규칙4 : 중복된 상수IN 조건이 정상적인 분리를 하지 않으면 ‘USE_CONCAT’ 힌트로 정상적인 분리 가능 (함부로 사용하지 말 것)
5. 규칙5 : 서브쿼리 뒤에 오는 IN조건은 실행계획 분리에 기여하지 못함
6. 규칙6 : 서브쿼리 앞에 위치한 IN조건이 실행계획분리에 참여하면 중복 수행함
